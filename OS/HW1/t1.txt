#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <time.h>
#include <string.h>
#include <sys/file.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <semaphore.h>

#define NUM 17
#define SIZE (NUM * sizeof(int))

void error_and_die(const char *msg) {
  perror(msg);
  exit(EXIT_FAILURE);
}

int find(int tmpx,int tmpy, int* arr, int tm)
{
	for(int i=1;i<=tm;++i)
	{
		if(tmpx==arr[i*2]&&tmpy==arr[i*2+1]) return 1;
	}
	
	return 0;
}

int main(void)
{

	pid_t pid;

	int r;

	const char *memname = "sample";
	const size_t region_size = sysconf(_SC_PAGE_SIZE);

	int fd = shm_open(memname, O_CREAT | O_TRUNC | O_RDWR, 0666);
	if (fd == -1)
	  error_and_die("shm_open");

	r = ftruncate(fd, region_size);
	if (r != 0)
	error_and_die("ftruncate");

	int *ptr = (int *)mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (ptr == MAP_FAILED)
	  error_and_die("mmap");
	
	int SEED, IM;
	printf("prog1 ");
	scanf("%d %d", &SEED, &IM);
	srand(SEED);
	
	    sem_t *p_sem = NULL;
	    
	    p_sem = mmap(NULL,                      /* 由系统分配地址 */
		         2 * sizeof(sem_t),         /* 申请的地址大小 */
		         PROT_READ  | PROT_WRITE,   /* 读写权限 */
		         MAP_SHARED | MAP_ANON,     /* 进程共享，映射区与文件不关联 */
		         -1,                        /* 文件描述符，匿名映射传入-1 */
		         0);                        /* 偏移量 */
		
	    sem_init(&p_sem[0], 1, 0);      /* 进程间使用的信号量，初值为0 */
	    sem_init(&p_sem[1], 1, 1);      /* 进程间使用的信号量，初值为1 */

	pid = fork();
	int count=0;

	if(pid<0)
	{
		fprintf(stderr,"Fork Failed\n");
		exit(-1);
	}
	else if(pid==0)
	{
            sem_wait(&p_sem[0]);
		int x, y;
		x=rand()%10, y=rand()%10;
		x=rand()%10, y=rand()%10;
		printf("[%dChild]:OK\n",getpid());

		sem_post(&p_sem[1]);
		for(int i=0;i<5;++i)
		{				
			sem_wait(&p_sem[0]);
			int tmpx=ptr[0]-x, tmpy=ptr[1]-y;
			if(tmpx==0&&tmpy==0) { ptr[6]=1;  printf("[%dChild]:You win\n",getpid()); i=6; ptr[4]=x, ptr[5]=y;}
			else if(i==4) { printf("[%dChild]:Miss, you lose\n",getpid()); ptr[4]=x, ptr[5]=y;}
			else if(tmpx==0) 
			{
				if(tmpy>0)
				{
					printf("[%dChild]:Miss up\n",getpid());
					ptr[13]=ptr[1];
				}
				else
				{
					printf("[%dChild]:Miss down\n",getpid());
					ptr[12]=ptr[1];
				} 
				ptr[9]=1, ptr[14]=1;
				ptr[10]=ptr[0],ptr[11]=ptr[0]; 
			}
			else if(tmpy==0) 
			{
				if(tmpx>0)
				{
					printf("[%dChild]:Miss left\n",getpid());
					ptr[11]=ptr[0];
				}
				else
				{ 
					printf("[%dChild]:Miss right\n",getpid());
					ptr[10]=ptr[0];
				} 
				ptr[8]=1, ptr[14]=1; 
				ptr[12]=ptr[1],ptr[13]=ptr[1];
			}
			else if(tmpx>0)
			{
				if(tmpy>0) {printf("[%dChild]:Miss up left\n",getpid()); ptr[11]=ptr[0], ptr[13]=ptr[1];}
				else {printf("[%dChild]:Miss down left\n",getpid()); ptr[11]=ptr[0], ptr[12]=ptr[1]; ptr[16]=1;}
			}
			else if(tmpx<0)
			{
				if(tmpy>0) {printf("[%dChild]:Miss up right\n",getpid()); ptr[10]=ptr[0], ptr[13]=ptr[1];ptr[15]=1;}
				else {printf("[%dChild]:Miss down right\n",getpid()); ptr[10]=ptr[0], ptr[12]=ptr[1];ptr[15]=1; ptr[16]=1;}
			}
			
			ptr[2]=tmpx, ptr[3]=tmpy;

			sem_post(&p_sem[1]);
		}

	}
	else
	{
            sem_wait(&p_sem[1]);
		ptr[6]=0, ptr[7]=SEED, ptr[8]=0, ptr[9]=0, ptr[14]=0, ptr[15]=0, ptr[16]=1;	
		printf("[%dParent]:Create a child %d\n",getpid(),pid);
            sem_post(&p_sem[0]);
		
		int /*_x=0, _y=0, x_=10, y_=10, */nowx=0, nowy=0;
		ptr[10]=0, ptr[11]=10, ptr[12]=0, ptr[13]=10;
		int ar[20];
		
		for(int i=0;i<5;++i)
		{
		   sem_wait(&p_sem[1]);
		
			if(ptr[6]) break;		
		
								
			if(ptr[14])
			{	
				while(find(nowx, nowy, ar, i))
				{
					if(ptr[11]-ptr[10]) nowx=rand()%(ptr[11]-ptr[10])+ptr[10];
					if(ptr[13]-ptr[12]) nowy=rand()%(ptr[13]-ptr[12])+ptr[12];
				}
			}				
			else
			{
				 //printf("%d %d %d %d\n",ptr[10], ptr[11], ptr[12], ptr[13]);
				 if(ptr[10]==0&&ptr[11]==10&&ptr[12]==0&&ptr[13]==10)
				 {
				 	 if(ptr[11]-ptr[10]) nowx=rand()%(ptr[11]-ptr[10])+ptr[10];
					 if(ptr[13]-ptr[12]) nowy=rand()%(ptr[13]-ptr[12])+ptr[12];
				 }
				 else if(ptr[10]==0&&ptr[11]==10&&ptr[12]==0&&ptr[13]==10&&ptr[15]&&ptr[16])
				 {
					 if(ptr[11]-ptr[10]) nowx=rand()%(ptr[11]-ptr[10]-1)+ptr[10]+1;
					 if(ptr[13]-ptr[12]) nowy=rand()%(ptr[13]-ptr[12]-1)+ptr[12]+1;
				 }
				 else
				 {
					 if((ptr[10]!=0||ptr[15])&&ptr[11]!=10)
					 {
					 	//printf("1\n");
					 	if(ptr[11]-ptr[10]) nowx=rand()%(ptr[11]-ptr[10]-2)+ptr[10]+1;
					 }
					 else if(ptr[10]!=0||ptr[15])
					 {
						//printf("2\n");							 
					 	if(ptr[11]-ptr[10]) nowx=rand()%(ptr[11]-ptr[10]-1)+ptr[10]+1;
					 }
					 else if(ptr[11]!=10)
					 {
					 	//printf("3\n");	
					 	if(ptr[11]-ptr[10]) nowx=rand()%(ptr[11]-ptr[10]-1)+ptr[10];
					 }
				
					 if((ptr[12]!=0||ptr[16])&&ptr[13]!=10)
					 {
						// printf("4\n");	
					 	if(ptr[13]-ptr[12]) nowy=rand()%(ptr[13]-ptr[12]-2)+ptr[12]+1;
					 }
					 else if(ptr[12]!=0||ptr[16])
					 {
						// printf("5\n");	
					 	if(ptr[13]-ptr[12]) nowy=rand()%(ptr[13]-ptr[12]-1)+ptr[12]+1;
					 }
					 else if(ptr[13]!=10)
					 {
						// printf("6\n");	
					 	if(ptr[13]-ptr[12]) nowy=rand()%(ptr[13]-ptr[12]-1)+ptr[12];
					 }
				 }
			}
			ptr[0]=nowx, ptr[1]=nowy;
			ar[(i+1)*2]=nowx, ar[(i+1)*2+1]=nowy;
			
			printf("[%dParent]:Guess[%d,%d]\n",getpid(),nowx,nowy);
			
        	    sem_post(&p_sem[0]);
		}
		
		waitpid(pid,NULL,0);
		
		printf("[%dParent]:Target[%d,%d]\n",getpid(), ptr[4], ptr[5]);
		
		if(IM)
		{
			printf("Cheating answer:No cheating answer!\n");
		}
		
		r = munmap(ptr, region_size);
		if (r != 0)
		  error_and_die("munmap");

		r = shm_unlink(memname);
		if (r != 0)
		  error_and_die("shm_unlink");
		close(fd);
		
	}

}